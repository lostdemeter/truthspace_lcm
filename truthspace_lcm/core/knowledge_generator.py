#!/usr/bin/env python3
"""
LLM-Powered Knowledge Generator

Uses Ollama to dynamically generate knowledge domains and entries,
then ingests them into the DynamicLCM.

This demonstrates that the geometric LCM can scale to arbitrary domains
without manual knowledge curation.
"""

import json
import requests
from typing import List, Dict, Optional, Generator
from dataclasses import dataclass


@dataclass
class GeneratedEntry:
    """A knowledge entry generated by the LLM."""
    content: str
    description: str
    domain: str


class KnowledgeGenerator:
    """
    Generates knowledge using an LLM via Ollama.
    
    The LLM generates:
    1. Domain suggestions based on a seed topic
    2. Knowledge entries for each domain
    3. Descriptions optimized for geometric encoding
    """
    
    def __init__(self, model: str = "qwen2:latest", base_url: str = "http://localhost:11434"):
        self.model = model
        self.base_url = base_url
        self.api_url = f"{base_url}/api/generate"
    
    def _query_llm(self, prompt: str, temperature: float = 0.7) -> str:
        """Send a prompt to Ollama and get the response."""
        payload = {
            "model": self.model,
            "prompt": prompt,
            "stream": False,
            "options": {
                "temperature": temperature,
                "num_predict": 2048,
            }
        }
        
        try:
            response = requests.post(self.api_url, json=payload, timeout=120)
            response.raise_for_status()
            return response.json().get("response", "")
        except requests.exceptions.RequestException as e:
            print(f"Error querying Ollama: {e}")
            return ""
    
    def generate_domains(self, seed_topic: str = None, count: int = 5) -> List[str]:
        """
        Generate domain suggestions.
        
        If seed_topic is provided, generates related domains.
        Otherwise, generates diverse general domains.
        """
        if seed_topic:
            prompt = f"""Generate {count} specific knowledge domains related to "{seed_topic}".

Return ONLY a JSON array of domain names, nothing else.
Each domain should be a single word or hyphenated phrase.
Example: ["gardening", "home-repair", "pet-care", "cooking", "fitness"]

Domains:"""
        else:
            prompt = f"""Generate {count} diverse knowledge domains that would be useful for a general-purpose assistant.

Return ONLY a JSON array of domain names, nothing else.
Each domain should be a single word or hyphenated phrase.
Include a mix of technical, practical, and creative domains.
Example: ["programming", "cooking", "medicine", "music", "finance"]

Domains:"""
        
        response = self._query_llm(prompt, temperature=0.8)
        
        # Parse JSON from response
        try:
            # Find JSON array in response
            start = response.find('[')
            end = response.rfind(']') + 1
            if start >= 0 and end > start:
                domains = json.loads(response[start:end])
                return [d.lower().replace(' ', '-') for d in domains if isinstance(d, str)]
        except json.JSONDecodeError:
            pass
        
        # Fallback: try to extract domain names from text
        domains = []
        for line in response.split('\n'):
            line = line.strip().strip('-').strip('*').strip('"').strip("'")
            if line and len(line) < 30 and ' ' not in line.replace('-', ''):
                domains.append(line.lower())
        
        return domains[:count]
    
    def generate_knowledge_for_domain(self, domain: str, count: int = 15) -> List[GeneratedEntry]:
        """
        Generate knowledge entries for a specific domain.
        
        Each entry has:
        - content: The actual response/command/fact
        - description: Keywords for geometric encoding
        """
        prompt = f"""Generate {count} knowledge entries for the domain "{domain}".

Each entry should be a practical piece of knowledge - a command, instruction, fact, or response.

Return a JSON array where each entry has:
- "content": The actual knowledge (command, instruction, fact, or response)
- "keywords": 8-12 keywords including: the domain name "{domain}", action verbs, and specific terms

IMPORTANT: Always include "{domain}" as one of the keywords.
Include common question words that might be used to ask about this topic.

Example for "cooking" domain:
[
  {{"content": "Preheat oven to 350Â°F before baking", "keywords": "cooking preheat oven temperature baking how prepare heat"}},
  {{"content": "Let meat rest 5 minutes after cooking", "keywords": "cooking rest meat after done juices temperature why wait"}}
]

Generate entries for "{domain}":"""
        
        response = self._query_llm(prompt, temperature=0.7)
        
        entries = []
        try:
            # Find JSON array in response
            start = response.find('[')
            end = response.rfind(']') + 1
            if start >= 0 and end > start:
                raw_entries = json.loads(response[start:end])
                for item in raw_entries:
                    if isinstance(item, dict) and 'content' in item:
                        content = item.get('content', '')
                        keywords = item.get('keywords', item.get('description', ''))
                        # Always include domain name in description
                        if domain.lower() not in keywords.lower():
                            keywords = f"{domain} {keywords}"
                        if content:
                            entries.append(GeneratedEntry(
                                content=content,
                                description=keywords,
                                domain=domain
                            ))
        except json.JSONDecodeError:
            # Try line-by-line parsing as fallback
            pass
        
        return entries
    
    def generate_corpus(self, domains: List[str] = None, 
                       entries_per_domain: int = 15,
                       seed_topic: str = None,
                       domain_count: int = 5) -> Generator[GeneratedEntry, None, None]:
        """
        Generate a full knowledge corpus.
        
        If domains is not provided, generates domains first.
        Yields entries as they are generated (streaming).
        """
        if domains is None:
            print(f"Generating {domain_count} domains...")
            domains = self.generate_domains(seed_topic=seed_topic, count=domain_count)
            print(f"Generated domains: {domains}")
        
        for domain in domains:
            print(f"\nGenerating {entries_per_domain} entries for '{domain}'...")
            entries = self.generate_knowledge_for_domain(domain, count=entries_per_domain)
            print(f"  Generated {len(entries)} entries")
            
            for entry in entries:
                yield entry
    
    def generate_test_queries(self, domains: List[str], queries_per_domain: int = 5) -> List[Dict]:
        """
        Generate test queries for evaluating the LCM.
        
        Returns queries with expected domain labels.
        """
        prompt = f"""Generate {queries_per_domain} natural language queries for each of these domains: {domains}

Each query should be something a user might ask. The query MUST include the domain name or a very closely related word.

Return a JSON array where each entry has:
- "query": The natural language query (MUST mention the domain or a synonym)
- "domain": Which domain it belongs to

Example for domains ["cooking", "gardening"]:
[
  {{"query": "what's a good cooking technique for steak", "domain": "cooking"}},
  {{"query": "how do I start gardening in small spaces", "domain": "gardening"}}
]

Generate queries for {domains}:"""
        
        response = self._query_llm(prompt, temperature=0.8)
        
        queries = []
        try:
            start = response.find('[')
            end = response.rfind(']') + 1
            if start >= 0 and end > start:
                queries = json.loads(response[start:end])
        except json.JSONDecodeError:
            pass
        
        return queries


def generate_and_save_corpus(output_path: str, 
                            domains: List[str] = None,
                            entries_per_domain: int = 15,
                            seed_topic: str = None,
                            domain_count: int = 5,
                            model: str = "qwen2:latest"):
    """
    Generate a corpus and save it to a JSON file.
    
    This can be used to pre-generate a corpus for later use.
    """
    generator = KnowledgeGenerator(model=model)
    
    corpus = {
        "metadata": {
            "model": model,
            "seed_topic": seed_topic,
            "entries_per_domain": entries_per_domain,
        },
        "domains": [],
        "entries": []
    }
    
    # Generate
    all_entries = list(generator.generate_corpus(
        domains=domains,
        entries_per_domain=entries_per_domain,
        seed_topic=seed_topic,
        domain_count=domain_count
    ))
    
    # Organize by domain
    domain_set = set()
    for entry in all_entries:
        domain_set.add(entry.domain)
        corpus["entries"].append({
            "content": entry.content,
            "description": entry.description,
            "domain": entry.domain
        })
    
    corpus["domains"] = list(domain_set)
    
    # Save
    with open(output_path, 'w') as f:
        json.dump(corpus, f, indent=2)
    
    print(f"\nSaved corpus to {output_path}")
    print(f"  Domains: {len(corpus['domains'])}")
    print(f"  Entries: {len(corpus['entries'])}")
    
    return corpus


if __name__ == "__main__":
    # Quick test
    generator = KnowledgeGenerator()
    
    print("Testing domain generation...")
    domains = generator.generate_domains(count=3)
    print(f"Domains: {domains}")
    
    if domains:
        print(f"\nTesting knowledge generation for '{domains[0]}'...")
        entries = generator.generate_knowledge_for_domain(domains[0], count=3)
        for entry in entries:
            print(f"  - {entry.content[:50]}...")
            print(f"    Keywords: {entry.description}")
